#include "ros/ros.h"
#include "geometry_msgs/Pose2D.h"
#include "geometry_msgs/Vector3.h"
#include <image_transport/image_transport.h>
#include <cv_bridge/cv_bridge.h>

//opencv
#include "opencv2/imgproc.hpp"
#include "opencv2/videoio.hpp"
#include <opencv2/highgui.hpp>
#include <opencv2/video.hpp>

#include <cmath>
#include <iostream>
#include <cv.h>
#include <highgui.h>

using namespace std;
using namespace cv;

#define FIELD_WIDTH     3.53  // in meters
#define FIELD_HEIGHT    2.39 
#define ROBOT_RADIUS    0.10
#define GUI_NAME        "Soccer Overhead Camera"

// Mouse click parameters, empirically found
// The smaller the number, the more positive the error
// (i.e., it will be above the mouse in +y region)
#define FIELD_WIDTH_PIXELS      577.0 // measured from threshold of goal to goal
#define FIELD_HEIGHT_PIXELS     388.0 // measured from inside of wall to wall
#define CAMERA_WIDTH            640.0
#define CAMERA_HEIGHT           480.0

// These colours need to match the Gazebo materials
Scalar red[]    = {Scalar(0,   128, 128), Scalar(10,  255, 255)};
Scalar yellow[] = {Scalar(20,  128, 128), Scalar(30,  255, 255)};
Scalar green[]  = {Scalar(55,  128, 128), Scalar(65,  255, 255)};
Scalar blue[]   = {Scalar(115, 128, 128), Scalar(125, 255, 255)};
Scalar purple[] = {Scalar(145, 128, 128), Scalar(155, 255, 255)};

// Handlers for vision position publishers
ros::Publisher home1_pub;
ros::Publisher home2_pub;
ros::Publisher away1_pub;
ros::Publisher away2_pub;
ros::Publisher ball_pub;
ros::Publisher ball_position_pub; // for publishing internally from the vision window

// Use variables to store position of objects. These variables are very
// useful when the ball cannot be seen, otherwise we'll get the position (0, 0)
geometry_msgs::Pose2D poseHome1;
geometry_msgs::Pose2D poseHome2;
geometry_msgs::Pose2D poseAway1;
geometry_msgs::Pose2D poseAway2;
geometry_msgs::Pose2D poseBall;


Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method

int iLowH = 0;
int iHighH = 179;

int iLowS = 0;
int iHighS = 255;

int iLowV = 0;
int iHighV = 255;


Point2d getCenterOfMass(Moments moment)
{
    double m10 = moment.m10;
    double m01 = moment.m01;
    double mass = moment.m00;
    double x = m10 / mass;
    double y = m01 / mass;
    return Point2d(x, y);
}

bool compareMomentAreas(Moments moment1, Moments moment2)
{
    double area1 = moment1.m00;
    double area2 = moment2.m00;
    return area1 < area2;
}


Point2d imageToWorldCoordinates(Point2d point_i)
{
    Point2d centerOfField(CAMERA_WIDTH/2, CAMERA_HEIGHT/2);
    Point2d center_w = (point_i - centerOfField);

    // You have to split up the pixel to meter conversion
    // because it is a rect, not a square!
    center_w.x *= (FIELD_WIDTH/FIELD_WIDTH_PIXELS);
    center_w.y *= (FIELD_HEIGHT/FIELD_HEIGHT_PIXELS);

    // Reflect y
    center_w.y = -center_w.y;

    return center_w;
}


void imageCallback(const sensor_msgs::ImageConstPtr& msg)
{


    try
    {
        Mat frame = cv_bridge::toCvShare(msg, "bgr8")->image; // msg -> to open cv frame

        Mat imgHSV;

        //pMOG2->apply(frame, fgMaskMOG2); // perform gausian

        cvtColor(frame, imgHSV, COLOR_BGR2HSV); //Convert the captured frame from BGR to HSV

        Mat imgThresholded;

        inRange(imgHSV, Scalar(iLowH, iLowS, iLowV), Scalar(iHighH, iHighS, iHighV), imgThresholded); //Threshold the image

        //morphological opening (remove small objects from the foreground)
        //erode(imgThresholded, imgThresholded, getStructuringElement(MORPH_ELLIPSE, Size(5, 5)) );
        //dilate( imgThresholded, imgThresholded, getStructuringElement(MORPH_ELLIPSE, Size(5, 5)) );

        //morphological closing (fill small holes in the foreground)
        erode(imgThresholded, imgThresholded, getStructuringElement(MORPH_ELLIPSE, Size(2, 2)) );
        dilate(imgThresholded, imgThresholded, getStructuringElement(MORPH_ELLIPSE, Size(2, 2)) );



       imshow(GUI_NAME, imgThresholded); // show the image





        vector< vector<Point> > contours;
        vector<Moments> mm;
        vector<Vec4i> hierarchy;
        findContours(imgThresholded, contours, hierarchy, CV_RETR_CCOMP, CV_CHAIN_APPROX_SIMPLE);

        if (hierarchy.size() == 2)
        {
        for(int i = 0; i < hierarchy.size(); i++)
            mm.push_back(moments((Mat)contours[i]));

        std::sort(mm.begin(), mm.end(), compareMomentAreas);
        Moments mmLarge = mm[mm.size() - 1];
        Moments mmSmall = mm[mm.size() - 2];

        Point2d centerLarge = imageToWorldCoordinates(getCenterOfMass(mmLarge));
        Point2d centerSmall = imageToWorldCoordinates(getCenterOfMass(mmSmall));

        Point2d robotCenter = (centerLarge + centerSmall) * (1.0 / 2);
        Point2d diff = centerSmall - centerLarge;
        double angle = atan2(diff.y, diff.x);

        //convert angle to degrees

        geometry_msgs::Pose2D robotPose;
        angle = angle *180/M_PI;
        robotPose.x = robotCenter.x;
        robotPose.y = robotCenter.y;
        robotPose.theta = angle;
        printf("x: %lf\n", robotPose.x);
        printf("y: %lf\n", robotPose.y);
        printf("th: %lf\n", robotPose.theta);

        home1_pub.publish(robotPose);





        // junk

        geometry_msgs::Pose2D fakePose;

        fakePose.x = 12;
        fakePose.y = 12;
        fakePose.theta = 12;
        home2_pub.publish(fakePose);

        fakePose.x = 21;
        fakePose.y = 21;
        fakePose.theta = 21;
        away1_pub.publish(fakePose);

        fakePose.x = 22;
        fakePose.y = 22;
        fakePose.theta = 22;
        away2_pub.publish(fakePose);

        fakePose.x = 0;
        fakePose.y = 0;
        fakePose.theta = 180;
        ball_pub.publish(fakePose);

        }
        else
        {
            printf("h size not 2");
        }




        waitKey(30);
    }
    catch (cv_bridge::Exception& e)
    {
        ROS_ERROR("Could not convert from '%s' to 'bgr8'.", msg->encoding.c_str());
    }
}


int main(int argc, char **argv)
{
    ros::init(argc, argv, "vision_sim");
    ros::NodeHandle nh;

    namedWindow("Control", CV_WINDOW_AUTOSIZE); //create a window called "Control"

     //Create trackbars in "Control" window
    cvCreateTrackbar("LowH", "Control", &iLowH, 179); //Hue (0 - 179)
    cvCreateTrackbar("HighH", "Control", &iHighH, 179);

    cvCreateTrackbar("LowS", "Control", &iLowS, 255); //Saturation (0 - 255)
    cvCreateTrackbar("HighS", "Control", &iHighS, 255);

    cvCreateTrackbar("LowV", "Control", &iLowV, 255); //Value (0 - 255)
    cvCreateTrackbar("HighV", "Control", &iHighV, 255);

    // Create OpenCV Window and add a mouse callback for clicking
    //setMouseCallback(GUI_NAME, mouseCallback, NULL);

    // Create ball publisher
    //ball_position_pub = nh.advertise<geometry_msgs::Vector3>("/ball/command", 1);

    pMOG2 = createBackgroundSubtractorMOG2(); //MOG2 approach

    // Subscribe to camera
    image_transport::ImageTransport it(nh);
    image_transport::Subscriber image_sub = it.subscribe("/usb_cam_away/image_raw", 1, imageCallback);

    home1_pub = nh.advertise<geometry_msgs::Pose2D>("home1", 5);
    home2_pub = nh.advertise<geometry_msgs::Pose2D>("home2", 5);
    away1_pub = nh.advertise<geometry_msgs::Pose2D>("away1", 5);
    away2_pub = nh.advertise<geometry_msgs::Pose2D>("away2", 5);
    ball_pub = nh.advertise<geometry_msgs::Pose2D>("ball", 5);

    // Create Vision Publishers
    //home1_pub = nh.advertise<geometry_msgs::Pose2D>("/vision/home1", 5);
    //home2_pub = nh.advertise<geometry_msgs::Pose2D>("/vision/home2", 5);
    //away1_pub = nh.advertise<geometry_msgs::Pose2D>("/vision/away1", 5);
    //away2_pub = nh.advertise<geometry_msgs::Pose2D>("/vision/away2", 5);
    //ball_pub = nh.advertise<geometry_msgs::Pose2D>("/vision/ball", 5);
    ros::spin();
    return 0;
}
